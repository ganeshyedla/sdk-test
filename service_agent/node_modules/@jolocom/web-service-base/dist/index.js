"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuidv4 = require('uuid').v4;
const QRCode = require("qrcode");
const sdk_1 = require("@jolocom/sdk");
;
const defaultRPCMap = {
// TODO
};
class JolocomWebServiceBase {
    constructor(agent, options = {}) {
        this._callbacks = {};
        this._basePath = '';
        this.agent = agent;
        this.rpcMap = options.rpcMap || defaultRPCMap;
        this.enableTls = !!options.tls;
        this.publicHostport = options.publicHostport || 'localhost:9000';
        this.paths = Object.assign({ interxn: '/interxn', chan: '/chan', rpc: '/rpc' }, options.paths);
    }
    createInteractionCallbackURL(cb) {
        const id = uuidv4();
        this._callbacks[id] = cb;
        return `${this.publicHttpUrl}${this.paths.interxn}/${id}`;
    }
    processCallback(cbId, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('received callback!!', cbId, payload);
            const cb = this._callbacks[cbId];
            if (!cb)
                throw new Error('no callback for ' + cbId);
            const tokenResp = yield cb(payload.token);
            if (tokenResp) {
                return { token: tokenResp.encode() }; // NOTE: legacy, smartwallet 1.9 expects this
            }
            else {
                // TODO return nothing
                return '';
            }
        });
    }
    set basePath(p) {
        this._basePath = p;
        const tls = this.enableTls ? 's' : '';
        this.publicWsUrl = `ws${tls}://${this.publicHostport || 'localhost'}${p}`;
        this.publicHttpUrl = `http${tls}://${this.publicHostport || 'localhost'}${p}`;
    }
    get basePath() {
        return this._basePath;
    }
    createChannel({ description }) {
        return __awaiter(this, void 0, void 0, function* () {
            const wsUrl = `${this.publicWsUrl}${this.paths.chan}`;
            const initTokenJwt = yield this.agent.establishChannelRequestToken({
                description,
                transports: [
                    {
                        type: sdk_1.ChannelTransportType.WebSockets,
                        config: wsUrl
                    }
                ]
            });
            const initInterxn = yield this.agent.findInteraction(initTokenJwt);
            if (!initInterxn)
                throw new Error("interaction (that was just created) cannot be found???");
            return this.agent.channels.create(initInterxn);
        });
    }
    processRPC(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this.rpcMap[msg.rpc];
            if (!handler)
                throw new Error('unknown RPC Call "' + msg.rpc + '"');
            const ctx = {
                wrapJWT: this.wrapJWT.bind(this),
                createChannel: this.createChannel.bind(this),
                createInteractionCallbackURL: this.createInteractionCallbackURL.bind(this)
            };
            const response = yield handler(msg.request, ctx);
            return {
                id: msg.id,
                request: msg,
                response
            };
        });
    }
    wrapJWT(tokenOrJwt) {
        return __awaiter(this, void 0, void 0, function* () {
            let jwt, token;
            if (typeof tokenOrJwt === 'string') {
                jwt = tokenOrJwt;
                token = sdk_1.JolocomLib.parse.interactionToken.fromJWT(jwt);
            }
            else {
                token = tokenOrJwt;
                jwt = token.encode();
            }
            const qr = yield QRCode.toDataURL(jwt);
            return {
                id: token.nonce,
                jwt,
                qr,
            };
        });
    }
}
exports.JolocomWebServiceBase = JolocomWebServiceBase;
//# sourceMappingURL=index.js.map