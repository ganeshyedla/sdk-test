"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialOfferFlow = void 0;
const types_1 = require("jolocom-lib/js/interactionTokens/types");
const jolocom_lib_1 = require("jolocom-lib");
const ramda_1 = require("ramda");
const flow_1 = require("./flow");
const types_2 = require("./types");
const guards_1 = require("./guards");
class CredentialOfferFlow extends flow_1.Flow {
    constructor(ctx) {
        super(ctx);
        this.state = {
            offerSummary: [],
            selection: [],
            selectedTypes: [],
            issued: [],
            credentialsValidity: [],
            credentialsAllValid: true,
        };
        this.type = types_2.FlowType.CredentialOffer;
    }
    async handleInteractionToken(token, interactionType) {
        switch (interactionType) {
            case types_1.InteractionType.CredentialOfferRequest:
                if (guards_1.isCredentialOfferRequest(token)) {
                    return this.handleOfferRequest(token);
                }
            case types_1.InteractionType.CredentialOfferResponse:
                if (guards_1.isCredentialOfferResponse(token)) {
                    return this.handleOfferResponse(token);
                }
            case types_1.InteractionType.CredentialsReceive:
                if (guards_1.isCredentialReceive(token)) {
                    return this.handleCredentialReceive(token);
                }
            default:
                throw new Error('Interaction type not found');
        }
    }
    handleOfferRequest(offer) {
        this.state.offerSummary = offer.offeredCredentials;
        return true;
    }
    areTypesOffered(types) {
        const { offerSummary } = this.state;
        if (!offerSummary)
            return false;
        return types.every(type => offerSummary.find(o => o.type == type));
    }
    async handleOfferResponse(token) {
        const selectedOffers = token.selectedCredentials;
        const selectedTypes = selectedOffers.map(offer => offer.type);
        if (!this.areTypesOffered(selectedTypes)) {
            throw new Error('Invalid offer type in offer response');
        }
        this.state.selection = selectedOffers;
        this.state.selectedTypes = selectedTypes;
        return true;
    }
    // Sets the validity map, currently if the issuer and if the subjects are correct.
    // also populates the SignedCredentialWithMetadata with credentials
    async handleCredentialReceive({ signedCredentials, }) {
        this.state.issued = signedCredentials;
        this.state.issued.map(cred => {
            const offer = this.state.offerSummary.find(({ type }) => type === ramda_1.last(cred.type));
            if (!offer) {
                throw new Error('Received wrong credentials');
            }
        });
        const validArr = (this.state.credentialsValidity = await Promise.all(signedCredentials.map(async (cred) => {
            try {
                await jolocom_lib_1.JolocomLib.parseAndValidate.signedCredential(cred.toJSON(), await this.ctx.ctx.ctx.resolve(cred.issuer));
            }
            catch (e) {
                return false;
            }
            return true;
        })));
        this.state.credentialsAllValid = validArr.every(v => v);
        return true;
    }
    // return a list of types which are both offered and requested
    getSelectionResult() {
        const offeredTypes = this.state.offerSummary.map(o => o.type);
        const selectedTypes = this.state.selection.map(s => s.type);
        return offeredTypes.filter(ot => selectedTypes.includes(ot));
    }
    getIssuanceResult() {
        return this.state.issued.map((cred, i) => {
            const offer = this.state.offerSummary.find(({ type }) => type === ramda_1.last(cred.type));
            if (!offer) {
                throw new Error('Received wrong credentials');
            }
            const validationErrors = {
                invalidIssuer: cred.issuer !== this.ctx.participants.requester.did,
                invalidSubject: cred.subject !== this.ctx.participants.responder.did,
            };
            if (validationErrors.invalidIssuer || validationErrors.invalidSubject) {
                this.state.credentialsValidity[i] = false;
                this.state.credentialsAllValid = false;
            }
            return {
                ...offer,
                signedCredential: cred,
                validationErrors,
            };
        });
    }
}
exports.CredentialOfferFlow = CredentialOfferFlow;
//# sourceMappingURL=credentialOfferFlow.js.map